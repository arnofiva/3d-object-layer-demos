import{hk as D,ba as $,hl as q,hm as z,ax as v,hn as C,ho as F,hp as G,hq as O,hr as E}from"./index-cdda5707.js";async function k(o,d,l,m,r){const{elevationProvider:h,renderCoordsHelper:c,spatialReference:I}=o,{elevationInfo:g}=d,y=q(g,!0),b=await z(y,I,r);v(r);const i=[],p=new Set,u=new Set;for(const{objectId:e,points:a}of m){const n=l(e);if(n==null){for(const s of a)i.push(s.z??0);p.add(e);continue}n.isDraped&&u.add(e);const t=n.graphic.geometry;w.setFromElevationInfo(C(t,g)),w.updateFeatureExpressionInfoContext(b,n.graphic,d),f.spatialReference=o.spatialReference;for(const{x:s,y:x,z:j}of a)f.x=s,f.y=x,f.z=j??0,F(f,h,w,c,R),i.push(R.z)}return{elevations:i,drapedObjectIds:u,failedObjectIds:p}}const w=new G,f=D(0,0,0,$.WGS84),R=new O;async function A(o,d,l){if(o==null||d.candidates.length===0)return S;const m=o.graphics3DGraphicsByObjectID??o.graphics3DGraphics,r=[],h=[],{renderer:c}=o,I=c!=null&&"arcadeRequired"in c&&c.arcadeRequired?E():null,g=async(e,{graphic:a,graphics3DSymbol:n})=>{const t=await I,s=await o.getRenderingInfoAsync(a,c,t,{signal:l});return s==null?[]:n.queryForSnapping(e,b,s,l)},{candidates:y,spatialReference:b}=d;for(let e=0;e<y.length;++e){const a=y[e],{objectId:n}=a,t=typeof n=="number"?m?.get(n):void 0;if(t==null)continue;const{graphics3DSymbol:s}=t;s.symbologySnappingSupported&&(r.push(g(a,t)),h.push(e))}if(r.length===0)return S;const i=await Promise.all(r);v(l);const p=[],u=[];for(let e=0;e<i.length;++e){const a=i[e],n=h[e];for(const t of a)p.push(t),u.push(n)}return{candidates:p,sourceCandidateIndices:u}}const S={candidates:[],sourceCandidateIndices:[]};export{k as f,A as r};
