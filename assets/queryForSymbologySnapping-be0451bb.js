import{bq as j,bA as $,hB as C,hC as q,ax as v,hD as z,hE as F,hF as G,hG as E}from"./main-79e5ed80.js";import{u as O}from"./elevationInfoUtils-287337e4.js";async function P(o,d,p,m,r){const{elevationProvider:h,renderCoordsHelper:i,spatialReference:I}=o,{elevationInfo:g}=d,y=C(g,!0),b=await q(y,I,r);v(r);const c=[],l=new Set,u=new Set;for(const{objectId:e,points:t}of m){const n=p(e);if(n==null){for(const s of t)c.push(s.z??0);l.add(e);continue}n.isDraped&&u.add(e);const a=n.graphic.geometry;w.setFromElevationInfo(O(a,g)),w.updateFeatureExpressionInfoContext(b,n.graphic,d),f.spatialReference=o.spatialReference;for(const{x:s,y:x,z:D}of t)f.x=s,f.y=x,f.z=D??0,z(f,h,w,i,R),c.push(R.z)}return{elevations:c,drapedObjectIds:u,failedObjectIds:l}}const w=new F,f=j(0,0,0,$.WGS84),R=new G;async function H(o,d,p){if(o==null||d.candidates.length===0)return S;const m=o.graphics3DGraphicsByObjectID??o.graphics3DGraphics,r=[],h=[],{renderer:i}=o,I=i!=null&&"arcadeRequired"in i&&i.arcadeRequired?E():null,g=async(e,{graphic:t,graphics3DSymbol:n})=>{const a=await I,s=await o.getRenderingInfoAsync(t,i,a,{signal:p});return s==null?[]:n.queryForSnapping(e,b,s,p)},{candidates:y,spatialReference:b}=d;for(let e=0;e<y.length;++e){const t=y[e],{objectId:n}=t,a=typeof n=="number"?m?.get(n):void 0;if(a==null)continue;const{graphics3DSymbol:s}=a;s.symbologySnappingSupported&&(r.push(g(t,a)),h.push(e))}if(r.length===0)return S;const c=await Promise.all(r);v(p);const l=[],u=[];for(let e=0;e<c.length;++e){const t=c[e],n=h[e];for(const a of t)l.push(a),u.push(n)}return{candidates:l,sourceCandidateIndices:u}}const S={candidates:[],sourceCandidateIndices:[]};export{P as f,H as r};
