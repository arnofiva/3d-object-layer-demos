import{cr as $,eT as E,ht as U,hu as j,aC as T,hv as A,hw as q,eh as F,aD as g,au as B,aE as _,aF as J}from"./main-79e5ed80.js";import{r as K}from"./dehydratedFeatureComparison-d30367d4.js";import{b as Q}from"./elevationInfoUtils-287337e4.js";import{U as V}from"./dragEventPipeline-491faa8f.js";import{e as W}from"./SnappingContext-d538137b.js";function rt({predicate:t=()=>!0,snappingManager:n,snappingContext:o,updatingHandles:s,useZ:e=!0}){const i=new V;if(n==null)return{snappingStep:[O,i],cancelSnapping:O};let l,p=null,a=null,c=null;const d=()=>{p=T(p),n.doneSnapping(),a?.frameTask.remove(),a=null,l=A(l),c=null},m=X(n,e,i);let h=null,u=null,b=null;return{snappingStep:[r=>{if(!t(r))return r;const{action:v}=r;if(v==="start"){const{info:x}=r,y=Y(n.view);if(a=tt(o,r,y),a.context.selfSnappingZ=null,!e&&x!=null){const P=et(o.coordinateHelper,x.handle.component);P!=null&&(a.context.selfSnappingZ={value:P,elevationInfo:o.elevationInfo??Q})}}if(a!=null){const{context:x,originalScenePos:y,originalPos:P}=a,{mapEnd:k,mapStart:Z,scenePoints:N}=r,S=G(P,C(k,Z)),z=C(Z,P),R={...r,action:"update"},D=a.context,w=nt(y,N),I=n.update({point:S,scenePoint:w,context:x});if(b=I,H(k,I,z,e),h=S,u=w,v!=="end"){const{frameTask:L}=a;p==null&&(p=new AbortController),c=M=>{s.addPromise(q(m({frameTask:L,event:R,context:D,point:S,scenePoint:w,delta:z,getLastState:()=>({point:h,scenePoint:u,updatePoint:M.forceUpdate?null:b})},p.signal)))},c({forceUpdate:!1}),l==null&&(l=$(()=>n.options.effectiveEnabled,()=>c?.({forceUpdate:!0})))}}return v==="end"&&d(),r},i],cancelSnapping:r=>(d(),r)}}function X(t,n,o){return F(async({frameTask:s,point:e,scenePoint:i,context:l,event:p,delta:a,getLastState:c},d)=>{const m=await s.schedule(()=>t.snap({point:e,scenePoint:i,context:l,signal:d}),d);if(m.valid){let h=await s.schedule(()=>m.apply(),d);const u=c();u.point!=null&&e!==u.point&&(h=t.update({point:u.point,scenePoint:u.scenePoint,context:l})),u.updatePoint!=null&&K(h,u.updatePoint)||(H(p.mapEnd,h,a,n),o.execute(p))}})}function Y(t){return t.type==="3d"?t.resourceController.scheduler.registerTask(E.SNAPPING):U}function tt(t,n,o){return{context:new W({editGeometryOperations:t.editGeometryOperations,elevationInfo:t.elevationInfo,pointer:t.pointer,vertexHandle:n.info!=null?n.info.handle:null,excludeFeature:t.excludeFeature,visualizer:t.visualizer}),originalPos:n.snapOrigin!=null?t.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:n.scenePoints!=null?n.scenePoints.sceneStart:null,frameTask:o}}function G(t,[n,o,s]){const e=j(t);return e.x+=n,e.y+=o,e.hasZ&&(e.z+=s),e}function nt(t,n){return t==null||n==null?null:G(t,C(n.sceneEnd,n.sceneStart))}function C(t,n){const o=t.hasZ&&n.hasZ?t.z-n.z:0;return[t.x-n.x,t.y-n.y,o]}function H(t,n,[o,s,e],i){t.x=n.x+o,t.y=n.y+s,i&&t.hasZ&&n.hasZ&&(t.z=n.z+e)}function et(t,n){if(!t.hasZ())return null;const o=n.vertices;let s=null;for(const e of o){const i=t.getZ(e.pos);if(s!=null&&i!=null&&Math.abs(i-s)>1e-6)return null;s==null&&(s=i)}return s}function O(t){return t}let f=class extends B{constructor(t){super(t),this.constrainResult=n=>n,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=F(async(n,o,s,e)=>{const i=this._frameTask;if(i==null)return;const l=await i.schedule(()=>o.snap({...n,context:s,signal:e}),e);l.valid&&await i.schedule(()=>{this.stagedPoint=l.apply(),n!==this._snapPoints&&this._snapPoints!=null&&(this.stagedPoint=o.update({...this._snapPoints,context:s}))},e)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(t){this._stagedPoint=this.constrainResult(t)}initialize(){const t=this.view.type==="3d"?this.view?.resourceController?.scheduler:null;this._frameTask=t!=null?t.registerTask(E.SNAPPING):U}destroy(){this._abortController=T(this._abortController),this._frameTask=A(this._frameTask)}update(t,n,o){this._snapPoints=t;const{point:s,scenePoint:e}=t,i=n.update({point:s,scenePoint:e,context:o});return this.stagedPoint=i,i}async snap(t,n,o){const{point:s,scenePoint:e}=t;return this.stagedPoint=n.update({point:s,scenePoint:e,context:o}),this._snapPoints=t,this._abortController==null&&(this._abortController=new AbortController),this._snap(t,n,o,this._abortController.signal)}async resnap(t,n){this._snapPoints!=null&&await this.snap(this._snapPoints,t,n)}abort(){this._abortController=T(this._abortController),this._snapPoints=null}};g([_({constructOnly:!0})],f.prototype,"view",void 0),g([_()],f.prototype,"stagedPoint",null),g([_()],f.prototype,"constrainResult",void 0),g([_()],f.prototype,"_stagedPoint",void 0),f=g([J("esri.views.interactive.snapping.SnappingOperation")],f);export{rt as f,f as p};
